---
import { formatDistance } from 'date-fns';

import { SITE_TITLE, SITE_DESCRIPTION, GITHUB_REPOS } from '../consts';

import { RoadmapSection } from '@/components/sections/roadmap';
import DefaultLayout from '@/layouts/DefaultLayout.astro';

function ghFetch(path, { params = {}, method = 'GET' } = {}) {
  const token = process.env.GITHUB_API_TOKEN;
  if (!token) {
    throw new Error('Missing GITHUB_API_TOKEN env var');
  }
  const url = new URL(
    path.startsWith('http') ? path : `https://api.github.com${path}`,
  );
  Object.entries(params).forEach(([k, v]) =>
    url.searchParams.set(k, String(v)),
  );

  return fetch(url, {
    method,
    headers: {
      Authorization: `Bearer ${token}`,
      Accept: 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28',
    },
  }).then(async (res) => {
    if (!res.ok) {
      const text = await res.text().catch(() => '');
      throw new Error(`GitHub API ${res.status} ${res.statusText}: ${text}`);
    }
    return res.json();
  });
}

async function fetchOpenIssues(repo) {
  const items = await ghFetch(`/repos/${repo}/issues`, {
    params: { state: 'open', per_page: 100 },
  });
  return items.filter((it) => !it.pull_request);
}

async function fetchOpenPRs(repo) {
  return ghFetch(`/repos/${repo}/pulls`, {
    params: { state: 'open', per_page: 100 },
  });
}

async function fetchRecentlyMergedPRs(repo, sinceISO) {
  const closedPRs = await ghFetch(`/repos/${repo}/pulls`, {
    params: {
      state: 'closed',
      per_page: 100,
      sort: 'updated',
      direction: 'desc',
    },
  });
  const since = new Date(sinceISO).getTime();
  return closedPRs.filter(
    (pr) => pr.merged_at && new Date(pr.merged_at).getTime() >= since,
  );
}

function normalizeDescription(body) {
  if (!body) return '';
  const trimmed = body.trim().replace(/\r/g, '');
  const firstParagraph = trimmed.split('\n\n')[0];
  const oneLine = firstParagraph.split('\n').slice(0, 5).join(' ');
  return oneLine.length > 600 ? `${oneLine.slice(0, 600)}â€¦` : oneLine;
}

function toRoadmapItem({ status, items, kind }) {
  return items.map((it) => {
    console.log(it);
    const title = it.title || '(no title)';
    const description = normalizeDescription(it.body);
    let date;
    if (kind === 'merged_pr') {
      date = it.merged_at || it.closed_at || it.updated_at || it.created_at;
    } else {
      date = it.updated_at || it.created_at;
    }
    return {
      status,
      title,
      description,
      date: formatDistance(new Date(date), new Date()),
      team: {
        name: it.user?.login ?? 'Unknown',
        image: it.user?.avatar_url ?? '/favicon/favicon-96x96.png',
      },
    };
  });
}

const thirtyDaysAgo = new Date(
  Date.now() - 30 * 24 * 60 * 60 * 1000,
).toISOString();

const perRepoPromises = GITHUB_REPOS.map(async (repo) => {
  const [issues, openPRs, mergedPRs] = await Promise.all([
    fetchOpenIssues(repo),
    fetchOpenPRs(repo),
    fetchRecentlyMergedPRs(repo, thirtyDaysAgo),
  ]);

  const planned = toRoadmapItem({
    status: 'Planned',
    items: issues,
    kind: 'issue',
  });
  const inProgress = toRoadmapItem({
    status: 'In Progress',
    items: openPRs,
    kind: 'open_pr',
  });
  const shipped = toRoadmapItem({
    status: 'Shipped',
    items: mergedPRs,
    kind: 'merged_pr',
  });

  return [...planned, ...inProgress, ...shipped];
});

const roadmapItems = (await Promise.all(perRepoPromises))
  .flat()
  .sort((a, b) => new Date(b.date) - new Date(a.date));
---

<DefaultLayout title={SITE_TITLE} description={SITE_DESCRIPTION}>
  <RoadmapSection client:visible roadmapItems={roadmapItems} />
</DefaultLayout>
